Shader "Lapanen/TRreeLODBillboard"
{
	Properties
	{
		[NoScaleOffset] Texture2D_CCD5CEA6("Texture2D", 2D) = "white" {}
	Vector1_E27FB99C("NormalStrength", Float) = 0
		[NoScaleOffset] Texture2D_45F933D("NormalMap", 2D) = "white" {}
	Vector1_38AC8A3D("AlphaClipThreshold", Float) = 0
		Vector1_85FB8AF6("Smooth", Float) = 0
		Vector1_273B1B33("Vector1", Float) = 0
		Color_4DA8DBE7("AlbedoColor", Color) = (0,0,0,0)
		Vector1_951C5AAE("WindSpeed", Float) = 0
		Vector1_CEA04AF4("WindDensitity", Float) = 0
		Vector1_239C1347("WindStrengt", Float) = 0

	}
		SubShader
	{
		Tags{ "RenderPipeline" = "LightweightPipeline" }
		Tags
	{
		"RenderPipeline" = "HDRenderPipeline"
		"RenderType" = "Transparent"
		"Queue" = "Transparent+0"
	}
		Pass
	{
		Tags{ "LightMode" = "LightweightForward" }

		// Material options generated by graph

		Blend SrcAlpha OneMinusSrcAlpha

		Cull Back

		ZTest LEqual

		ZWrite Off

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
#pragma prefer_hlslcc gles
#pragma exclude_renderers d3d11_9x
#pragma target 2.0

		// -------------------------------------
		// Lightweight Pipeline keywords
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
#pragma multi_compile _ _SHADOWS_SOFT
#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE
#pragma multi_compile _ LOD_FADE_CROSSFADE
		// -------------------------------------
		// Unity defined keywords
#pragma multi_compile _ DIRLIGHTMAP_COMBINED
#pragma multi_compile _ LIGHTMAP_ON
#pragma multi_compile_fog

		//--------------------------------------
		// GPU Instancing
#pragma multi_compile_instancing

#pragma vertex vert
#pragma fragment frag

		// Defines generated by graph
#define _NORMALMAP 1
#define _AlphaClip 1

#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float Vector1_E27FB99C;
	float Vector1_38AC8A3D;
	float Vector1_85FB8AF6;
	float Vector1_273B1B33;
	float4 Color_4DA8DBE7;
	float Vector1_951C5AAE;
	float Vector1_CEA04AF4;
	float Vector1_239C1347;
	CBUFFER_END

		TEXTURE2D(Texture2D_CCD5CEA6); SAMPLER(samplerTexture2D_CCD5CEA6); float4 Texture2D_CCD5CEA6_TexelSize;
	TEXTURE2D(Texture2D_45F933D); SAMPLER(samplerTexture2D_45F933D); float4 Texture2D_45F933D_TexelSize;

	struct VertexDescriptionInputs
	{
		float3 WorldSpaceNormal;
		float3 WorldSpaceTangent;
		float3 WorldSpaceBiTangent;
		float3 WorldSpacePosition;
		half4 uv0;
	};

	struct SurfaceDescriptionInputs
	{
		float4 ScreenPosition;
		half4 uv0;
	};


	void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
	{
		RGBA = float4(R, G, B, A);
		RGB = float3(R, G, B);
		RG = float2(R, G);
	}

	void Unity_Multiply_float(float A, float B, out float Out)
	{
		Out = A * B;
	}

	void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
	{
		Out = UV * Tiling + Offset;
	}


	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

	void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
	{
		Out = unity_gradientNoise(UV * Scale) + 0.5;
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	void Unity_OneMinus_float(float In, out float Out)
	{
		Out = 1 - In;
	}

	void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
	{
		Out = lerp(A, B, T);
	}

	void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
	{
		Out = A * B;
	}

	void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
	{
		Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
	}

	void Unity_Dither_float(float In, float4 ScreenPosition, out float Out)
	{
		float2 uv = ScreenPosition.xy * _ScreenParams.xy;
		float DITHER_THRESHOLDS[16] =
		{
			1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
			13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
			4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
			16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
		};
		uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
		Out = In - DITHER_THRESHOLDS[index];
	}

	void FadeSwith_float(out float Out)
	{
#ifdef LOD_FADE_CROSSFADE
		Out = 1;
#else
		Out = 0;
#endif

	}

	void Unity_Comparison_Equal_float(float A, float B, out float Out)
	{
		Out = A == B ? 1 : 0;
	}

	void StarFunction_float(out float Out)
	{
		//#ifdef LOD_FADE_CROSSFADE
		Out = unity_LODFade.x;
		//#else
		//            Out =  1;
		//#endif

	}

	void Unity_Subtract_float(float A, float B, out float Out)
	{
		Out = A - B;
	}

	void Unity_Branch_float(float Predicate, float True, float False, out float Out)
	{
		Out = lerp(False, True, Predicate);
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		float _Split_7D802A88_R = IN.WorldSpacePosition[0];
		float _Split_7D802A88_G = IN.WorldSpacePosition[1];
		float _Split_7D802A88_B = IN.WorldSpacePosition[2];
		float _Split_7D802A88_A = 0;
		float4 _Combine_C6EF8810_RGBA;
		float3 _Combine_C6EF8810_RGB;
		float2 _Combine_C6EF8810_RG;
		Unity_Combine_float(_Split_7D802A88_R, _Split_7D802A88_G, 0, 0, _Combine_C6EF8810_RGBA, _Combine_C6EF8810_RGB, _Combine_C6EF8810_RG);
		float _Property_74A5754C_Out = Vector1_951C5AAE;
		float _Multiply_D0C65F21_Out;
		Unity_Multiply_float(_Time.y, _Property_74A5754C_Out, _Multiply_D0C65F21_Out);

		float2 _TilingAndOffset_A4885A2_Out;
		Unity_TilingAndOffset_float(_Combine_C6EF8810_RG, float2 (1,1), (_Multiply_D0C65F21_Out.xx), _TilingAndOffset_A4885A2_Out);
		float _Property_60AB6604_Out = Vector1_CEA04AF4;
		float _GradientNoise_99BA3CCA_Out;
		Unity_GradientNoise_float(_TilingAndOffset_A4885A2_Out, _Property_60AB6604_Out, _GradientNoise_99BA3CCA_Out);
		float _Add_98795D5D_Out;
		Unity_Add_float(_GradientNoise_99BA3CCA_Out, -0.5, _Add_98795D5D_Out);
		float _Property_B8B406BC_Out = Vector1_239C1347;
		float _Multiply_57AEF7C0_Out;
		Unity_Multiply_float(_Add_98795D5D_Out, _Property_B8B406BC_Out, _Multiply_57AEF7C0_Out);

		float _Split_A6731F17_R = IN.WorldSpacePosition[0];
		float _Split_A6731F17_G = IN.WorldSpacePosition[1];
		float _Split_A6731F17_B = IN.WorldSpacePosition[2];
		float _Split_A6731F17_A = 0;
		float _Add_4A836434_Out;
		Unity_Add_float(_Multiply_57AEF7C0_Out, _Split_A6731F17_R, _Add_4A836434_Out);
		float4 _Combine_CD92B7DE_RGBA;
		float3 _Combine_CD92B7DE_RGB;
		float2 _Combine_CD92B7DE_RG;
		Unity_Combine_float(_Add_4A836434_Out, _Split_A6731F17_G, _Split_A6731F17_B, 0, _Combine_CD92B7DE_RGBA, _Combine_CD92B7DE_RGB, _Combine_CD92B7DE_RG);
		float4 _UV_C5A2ED5A_Out = IN.uv0;
		float _Split_53CDB402_R = _UV_C5A2ED5A_Out[0];
		float _Split_53CDB402_G = _UV_C5A2ED5A_Out[1];
		float _Split_53CDB402_B = _UV_C5A2ED5A_Out[2];
		float _Split_53CDB402_A = _UV_C5A2ED5A_Out[3];
		float _OneMinus_D1530D6F_Out;
		Unity_OneMinus_float(_Split_53CDB402_R, _OneMinus_D1530D6F_Out);
		float3 _Lerp_A0CD34FA_Out;
		Unity_Lerp_float3(IN.WorldSpacePosition, _Combine_CD92B7DE_RGB, (_OneMinus_D1530D6F_Out.xxx), _Lerp_A0CD34FA_Out);
		float3 _Transform_29C2EC02_Out = TransformWorldToObject(_Lerp_A0CD34FA_Out.xyz);
		description.Position = _Transform_29C2EC02_Out;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Normal;
		float3 Emission;
		float Metallic;
		float Smoothness;
		float Occlusion;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float4 _SampleTexture2D_E05DA7F9_RGBA = SAMPLE_TEXTURE2D(Texture2D_CCD5CEA6, samplerTexture2D_CCD5CEA6, IN.uv0.xy);
		float _SampleTexture2D_E05DA7F9_R = _SampleTexture2D_E05DA7F9_RGBA.r;
		float _SampleTexture2D_E05DA7F9_G = _SampleTexture2D_E05DA7F9_RGBA.g;
		float _SampleTexture2D_E05DA7F9_B = _SampleTexture2D_E05DA7F9_RGBA.b;
		float _SampleTexture2D_E05DA7F9_A = _SampleTexture2D_E05DA7F9_RGBA.a;
		float4 _Property_E3377556_Out = Color_4DA8DBE7;
		float4 _Multiply_EEAD26D1_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_RGBA, _Property_E3377556_Out, _Multiply_EEAD26D1_Out);

		float4 _SampleTexture2D_937890C0_RGBA = SAMPLE_TEXTURE2D(Texture2D_45F933D, samplerTexture2D_45F933D, IN.uv0.xy);
		_SampleTexture2D_937890C0_RGBA.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_937890C0_RGBA);
		float _SampleTexture2D_937890C0_R = _SampleTexture2D_937890C0_RGBA.r;
		float _SampleTexture2D_937890C0_G = _SampleTexture2D_937890C0_RGBA.g;
		float _SampleTexture2D_937890C0_B = _SampleTexture2D_937890C0_RGBA.b;
		float _SampleTexture2D_937890C0_A = _SampleTexture2D_937890C0_RGBA.a;
		float _Property_779BA369_Out = Vector1_E27FB99C;
		float3 _NormalStrength_BBFB3307_Out;
		Unity_NormalStrength_float((_SampleTexture2D_937890C0_RGBA.xyz), _Property_779BA369_Out, _NormalStrength_BBFB3307_Out);
		float _Property_F40051D4_Out = Vector1_85FB8AF6;
		float4 _ScreenPosition_D28E9864_Out = float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0);
		float _Dither_643A0E60_Out;
		Unity_Dither_float(2, _ScreenPosition_D28E9864_Out, _Dither_643A0E60_Out);
		float _Multiply_DC3E7522_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_A, _Dither_643A0E60_Out, _Multiply_DC3E7522_Out);

		float _BranchLOD_96078242_Out;
		FadeSwith_float(_BranchLOD_96078242_Out);
		float _Comparison_ACF5C7CE_Out;
		Unity_Comparison_Equal_float(_BranchLOD_96078242_Out, 1, _Comparison_ACF5C7CE_Out);
		float _pLABLOD_5439991_Out;
		StarFunction_float(_pLABLOD_5439991_Out);
		float _Subtract_FEFCB1D5_Out;
		Unity_Subtract_float(1, _pLABLOD_5439991_Out, _Subtract_FEFCB1D5_Out);
		float _Property_C55ABFC9_Out = Vector1_38AC8A3D;
		float _Add_35D2C483_Out;
		Unity_Add_float(_Subtract_FEFCB1D5_Out, _Property_C55ABFC9_Out, _Add_35D2C483_Out);
		float _Branch_F0F84D1C_Out;
		Unity_Branch_float(_Comparison_ACF5C7CE_Out, _Add_35D2C483_Out, _Property_C55ABFC9_Out, _Branch_F0F84D1C_Out);
		surface.Albedo = (_Multiply_EEAD26D1_Out.xyz);
		surface.Normal = _NormalStrength_BBFB3307_Out;
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Metallic = 0;
		surface.Smoothness = _Property_F40051D4_Out;
		surface.Occlusion = 1;
		surface.Alpha = _Multiply_DC3E7522_Out;
		surface.AlphaClipThreshold = _Branch_F0F84D1C_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct GraphVertexOutput
	{
		float4 clipPos                : SV_POSITION;
		DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
		half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
		float4 shadowCoord            : TEXCOORD2;

		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		float4 ScreenPosition : TEXCOORD8;
		half4 uv0 : TEXCOORD9;
		half4 uv1 : TEXCOORD10;

		UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
	};

	GraphVertexOutput vert(GraphVertexInput v)
	{
		GraphVertexOutput o = (GraphVertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.WorldSpaceNormal = WorldSpaceNormal;
		vdi.WorldSpaceTangent = WorldSpaceTangent;
		vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
		vdi.WorldSpacePosition = WorldSpacePosition;
		vdi.uv0 = uv0;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.ScreenPosition = ScreenPosition;
		o.uv0 = uv0;
		o.uv1 = uv1;

		float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

		VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);

		// We either sample GI from lightmap or SH.
		// Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
		// see DECLARE_LIGHTMAP_OR_SH macro.
		// The following funcions initialize the correct variable with correct data
		OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
		OUTPUT_SH(lwWNormal, o.vertexSH);

		half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
		half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
		o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
		o.clipPos = vertexInput.positionCS;

#ifdef _MAIN_LIGHT_SHADOWS
		o.shadowCoord = GetShadowCoord(vertexInput);
#endif
		return o;
	}

	half4 frag(GraphVertexOutput IN) : SV_Target
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float4 ScreenPosition = IN.ScreenPosition;
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.ScreenPosition = ScreenPosition;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Specular = float3(0, 0, 0);
	float Metallic = 1;
	float3 Normal = float3(0, 0, 1);
	float3 Emission = 0;
	float Smoothness = 0.5;
	float Occlusion = 1;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Normal = surf.Normal;
	Emission = surf.Emission;
	Metallic = surf.Metallic;
	Smoothness = surf.Smoothness;
	Occlusion = surf.Occlusion;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

	InputData inputData;
	inputData.positionWS = WorldSpacePosition;

#ifdef _NORMALMAP
	inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
#else
#if !SHADER_HINT_NICE_QUALITY
	inputData.normalWS = WorldSpaceNormal;
#else
	inputData.normalWS = normalize(WorldSpaceNormal);
#endif
#endif

#if !SHADER_HINT_NICE_QUALITY
	// viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
	inputData.viewDirectionWS = WorldSpaceViewDirection;
#else
	inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
#endif

	inputData.shadowCoord = IN.shadowCoord;

	inputData.fogCoord = IN.fogFactorAndVertexLight.x;
	inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
	inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

	half4 color = LightweightFragmentPBR(
		inputData,
		Albedo,
		Metallic,
		Specular,
		Smoothness,
		Occlusion,
		Emission,
		Alpha);

	// Computes fog factor per-vertex
	color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

#if _AlphaClip
	clip(Alpha - AlphaClipThreshold);
#endif
	return color;
	}

		ENDHLSL
	}
		Pass
	{
		Name "ShadowCaster"
		Tags{ "LightMode" = "ShadowCaster" }

		ZWrite On ZTest LEqual

		// Material options generated by graph
		Cull Back

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
#pragma prefer_hlslcc gles
#pragma exclude_renderers d3d11_9x
#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
#pragma multi_compile_instancing

#pragma vertex ShadowPassVertex
#pragma fragment ShadowPassFragment

		// Defines generated by graph
#define _NORMALMAP 1
#define _AlphaClip 1

#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float Vector1_E27FB99C;
	float Vector1_38AC8A3D;
	float Vector1_85FB8AF6;
	float Vector1_273B1B33;
	float4 Color_4DA8DBE7;
	float Vector1_951C5AAE;
	float Vector1_CEA04AF4;
	float Vector1_239C1347;
	CBUFFER_END

		TEXTURE2D(Texture2D_CCD5CEA6); SAMPLER(samplerTexture2D_CCD5CEA6); float4 Texture2D_CCD5CEA6_TexelSize;
	TEXTURE2D(Texture2D_45F933D); SAMPLER(samplerTexture2D_45F933D); float4 Texture2D_45F933D_TexelSize;

	struct VertexDescriptionInputs
	{
		float3 WorldSpaceNormal;
		float3 WorldSpaceTangent;
		float3 WorldSpaceBiTangent;
		float3 WorldSpacePosition;
		half4 uv0;
	};

	struct SurfaceDescriptionInputs
	{
		float4 ScreenPosition;
		half4 uv0;
	};


	void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
	{
		RGBA = float4(R, G, B, A);
		RGB = float3(R, G, B);
		RG = float2(R, G);
	}

	void Unity_Multiply_float(float A, float B, out float Out)
	{
		Out = A * B;
	}

	void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
	{
		Out = UV * Tiling + Offset;
	}


	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

	void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
	{
		Out = unity_gradientNoise(UV * Scale) + 0.5;
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	void Unity_OneMinus_float(float In, out float Out)
	{
		Out = 1 - In;
	}

	void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
	{
		Out = lerp(A, B, T);
	}

	void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
	{
		Out = A * B;
	}

	void Unity_Dither_float(float In, float4 ScreenPosition, out float Out)
	{
		float2 uv = ScreenPosition.xy * _ScreenParams.xy;
		float DITHER_THRESHOLDS[16] =
		{
			1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
			13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
			4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
			16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
		};
		uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
		Out = In - DITHER_THRESHOLDS[index];
	}

	void FadeSwith_float(out float Out)
	{
#ifdef LOD_FADE_CROSSFADE
		Out = 1;
#else
		Out = 0;
#endif

	}

	void Unity_Comparison_Equal_float(float A, float B, out float Out)
	{
		Out = A == B ? 1 : 0;
	}

	void StarFunction_float(out float Out)
	{
		//#ifdef LOD_FADE_CROSSFADE
		Out = unity_LODFade.x;
		//#else
		//            Out =  1;
		//#endif

	}

	void Unity_Subtract_float(float A, float B, out float Out)
	{
		Out = A - B;
	}

	void Unity_Branch_float(float Predicate, float True, float False, out float Out)
	{
		Out = lerp(False, True, Predicate);
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		float _Split_7D802A88_R = IN.WorldSpacePosition[0];
		float _Split_7D802A88_G = IN.WorldSpacePosition[1];
		float _Split_7D802A88_B = IN.WorldSpacePosition[2];
		float _Split_7D802A88_A = 0;
		float4 _Combine_C6EF8810_RGBA;
		float3 _Combine_C6EF8810_RGB;
		float2 _Combine_C6EF8810_RG;
		Unity_Combine_float(_Split_7D802A88_R, _Split_7D802A88_G, 0, 0, _Combine_C6EF8810_RGBA, _Combine_C6EF8810_RGB, _Combine_C6EF8810_RG);
		float _Property_74A5754C_Out = Vector1_951C5AAE;
		float _Multiply_D0C65F21_Out;
		Unity_Multiply_float(_Time.y, _Property_74A5754C_Out, _Multiply_D0C65F21_Out);

		float2 _TilingAndOffset_A4885A2_Out;
		Unity_TilingAndOffset_float(_Combine_C6EF8810_RG, float2 (1,1), (_Multiply_D0C65F21_Out.xx), _TilingAndOffset_A4885A2_Out);
		float _Property_60AB6604_Out = Vector1_CEA04AF4;
		float _GradientNoise_99BA3CCA_Out;
		Unity_GradientNoise_float(_TilingAndOffset_A4885A2_Out, _Property_60AB6604_Out, _GradientNoise_99BA3CCA_Out);
		float _Add_98795D5D_Out;
		Unity_Add_float(_GradientNoise_99BA3CCA_Out, -0.5, _Add_98795D5D_Out);
		float _Property_B8B406BC_Out = Vector1_239C1347;
		float _Multiply_57AEF7C0_Out;
		Unity_Multiply_float(_Add_98795D5D_Out, _Property_B8B406BC_Out, _Multiply_57AEF7C0_Out);

		float _Split_A6731F17_R = IN.WorldSpacePosition[0];
		float _Split_A6731F17_G = IN.WorldSpacePosition[1];
		float _Split_A6731F17_B = IN.WorldSpacePosition[2];
		float _Split_A6731F17_A = 0;
		float _Add_4A836434_Out;
		Unity_Add_float(_Multiply_57AEF7C0_Out, _Split_A6731F17_R, _Add_4A836434_Out);
		float4 _Combine_CD92B7DE_RGBA;
		float3 _Combine_CD92B7DE_RGB;
		float2 _Combine_CD92B7DE_RG;
		Unity_Combine_float(_Add_4A836434_Out, _Split_A6731F17_G, _Split_A6731F17_B, 0, _Combine_CD92B7DE_RGBA, _Combine_CD92B7DE_RGB, _Combine_CD92B7DE_RG);
		float4 _UV_C5A2ED5A_Out = IN.uv0;
		float _Split_53CDB402_R = _UV_C5A2ED5A_Out[0];
		float _Split_53CDB402_G = _UV_C5A2ED5A_Out[1];
		float _Split_53CDB402_B = _UV_C5A2ED5A_Out[2];
		float _Split_53CDB402_A = _UV_C5A2ED5A_Out[3];
		float _OneMinus_D1530D6F_Out;
		Unity_OneMinus_float(_Split_53CDB402_R, _OneMinus_D1530D6F_Out);
		float3 _Lerp_A0CD34FA_Out;
		Unity_Lerp_float3(IN.WorldSpacePosition, _Combine_CD92B7DE_RGB, (_OneMinus_D1530D6F_Out.xxx), _Lerp_A0CD34FA_Out);
		float3 _Transform_29C2EC02_Out = TransformWorldToObject(_Lerp_A0CD34FA_Out.xyz);
		description.Position = _Transform_29C2EC02_Out;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float4 _SampleTexture2D_E05DA7F9_RGBA = SAMPLE_TEXTURE2D(Texture2D_CCD5CEA6, samplerTexture2D_CCD5CEA6, IN.uv0.xy);
		float _SampleTexture2D_E05DA7F9_R = _SampleTexture2D_E05DA7F9_RGBA.r;
		float _SampleTexture2D_E05DA7F9_G = _SampleTexture2D_E05DA7F9_RGBA.g;
		float _SampleTexture2D_E05DA7F9_B = _SampleTexture2D_E05DA7F9_RGBA.b;
		float _SampleTexture2D_E05DA7F9_A = _SampleTexture2D_E05DA7F9_RGBA.a;
		float4 _Property_E3377556_Out = Color_4DA8DBE7;
		float4 _Multiply_EEAD26D1_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_RGBA, _Property_E3377556_Out, _Multiply_EEAD26D1_Out);

		float4 _ScreenPosition_D28E9864_Out = float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0);
		float _Dither_643A0E60_Out;
		Unity_Dither_float(2, _ScreenPosition_D28E9864_Out, _Dither_643A0E60_Out);
		float _Multiply_DC3E7522_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_A, _Dither_643A0E60_Out, _Multiply_DC3E7522_Out);

		float _BranchLOD_96078242_Out;
		FadeSwith_float(_BranchLOD_96078242_Out);
		float _Comparison_ACF5C7CE_Out;
		Unity_Comparison_Equal_float(_BranchLOD_96078242_Out, 1, _Comparison_ACF5C7CE_Out);
		float _pLABLOD_5439991_Out;
		StarFunction_float(_pLABLOD_5439991_Out);
		float _Subtract_FEFCB1D5_Out;
		Unity_Subtract_float(1, _pLABLOD_5439991_Out, _Subtract_FEFCB1D5_Out);
		float _Property_C55ABFC9_Out = Vector1_38AC8A3D;
		float _Add_35D2C483_Out;
		Unity_Add_float(_Subtract_FEFCB1D5_Out, _Property_C55ABFC9_Out, _Add_35D2C483_Out);
		float _Branch_F0F84D1C_Out;
		Unity_Branch_float(_Comparison_ACF5C7CE_Out, _Add_35D2C483_Out, _Property_C55ABFC9_Out, _Branch_F0F84D1C_Out);
		surface.Albedo = (_Multiply_EEAD26D1_Out.xyz);
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Alpha = _Multiply_DC3E7522_Out;
		surface.AlphaClipThreshold = _Branch_F0F84D1C_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		float4 ScreenPosition : TEXCOORD8;
		half4 uv0 : TEXCOORD9;
		half4 uv1 : TEXCOORD10;

		UNITY_VERTEX_INPUT_INSTANCE_ID
	};

	// x: global clip space bias, y: normal world space bias
	float4 _ShadowBias;
	float3 _LightDirection;

	VertexOutput ShadowPassVertex(GraphVertexInput v)
	{
		VertexOutput o;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.WorldSpaceNormal = WorldSpaceNormal;
		vdi.WorldSpaceTangent = WorldSpaceTangent;
		vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
		vdi.WorldSpacePosition = WorldSpacePosition;
		vdi.uv0 = uv0;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.ScreenPosition = ScreenPosition;
		o.uv0 = uv0;
		o.uv1 = uv1;


		float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
		float3 normalWS = TransformObjectToWorldDir(v.normal);

		float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
		float scale = invNdotL * _ShadowBias.y;

		// normal bias is negative since we want to apply an inset normal offset
		positionWS = normalWS * scale.xxx + positionWS;
		float4 clipPos = TransformWorldToHClip(positionWS);

		// _ShadowBias.x sign depens on if platform has reversed z buffer
		clipPos.z += _ShadowBias.x;

#if UNITY_REVERSED_Z
		clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
#else
		clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
#endif
		o.clipPos = clipPos;

		return o;
	}

	half4 ShadowPassFragment(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float4 ScreenPosition = IN.ScreenPosition;
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.ScreenPosition = ScreenPosition;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	clip(Alpha - AlphaClipThreshold);
#endif
	return 0;
	}

		ENDHLSL
	}

		Pass
	{
		Name "DepthOnly"
		Tags{ "LightMode" = "DepthOnly" }

		ZWrite On
		ColorMask 0

		// Material options generated by graph
		Cull Back

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
#pragma prefer_hlslcc gles
#pragma exclude_renderers d3d11_9x
#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
#pragma multi_compile_instancing

#pragma vertex vert
#pragma fragment frag

		// Defines generated by graph
#define _NORMALMAP 1
#define _AlphaClip 1

#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float Vector1_E27FB99C;
	float Vector1_38AC8A3D;
	float Vector1_85FB8AF6;
	float Vector1_273B1B33;
	float4 Color_4DA8DBE7;
	float Vector1_951C5AAE;
	float Vector1_CEA04AF4;
	float Vector1_239C1347;
	CBUFFER_END

		TEXTURE2D(Texture2D_CCD5CEA6); SAMPLER(samplerTexture2D_CCD5CEA6); float4 Texture2D_CCD5CEA6_TexelSize;
	TEXTURE2D(Texture2D_45F933D); SAMPLER(samplerTexture2D_45F933D); float4 Texture2D_45F933D_TexelSize;

	struct VertexDescriptionInputs
	{
		float3 WorldSpaceNormal;
		float3 WorldSpaceTangent;
		float3 WorldSpaceBiTangent;
		float3 WorldSpacePosition;
		half4 uv0;
	};

	struct SurfaceDescriptionInputs
	{
		float4 ScreenPosition;
		half4 uv0;
	};


	void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
	{
		RGBA = float4(R, G, B, A);
		RGB = float3(R, G, B);
		RG = float2(R, G);
	}

	void Unity_Multiply_float(float A, float B, out float Out)
	{
		Out = A * B;
	}

	void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
	{
		Out = UV * Tiling + Offset;
	}


	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

	void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
	{
		Out = unity_gradientNoise(UV * Scale) + 0.5;
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	void Unity_OneMinus_float(float In, out float Out)
	{
		Out = 1 - In;
	}

	void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
	{
		Out = lerp(A, B, T);
	}

	void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
	{
		Out = A * B;
	}

	void Unity_Dither_float(float In, float4 ScreenPosition, out float Out)
	{
		float2 uv = ScreenPosition.xy * _ScreenParams.xy;
		float DITHER_THRESHOLDS[16] =
		{
			1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
			13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
			4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
			16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
		};
		uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
		Out = In - DITHER_THRESHOLDS[index];
	}

	void FadeSwith_float(out float Out)
	{
#ifdef LOD_FADE_CROSSFADE
		Out = 1;
#else
		Out = 0;
#endif

	}

	void Unity_Comparison_Equal_float(float A, float B, out float Out)
	{
		Out = A == B ? 1 : 0;
	}

	void StarFunction_float(out float Out)
	{
		//#ifdef LOD_FADE_CROSSFADE
		Out = unity_LODFade.x;
		//#else
		//            Out =  1;
		//#endif

	}

	void Unity_Subtract_float(float A, float B, out float Out)
	{
		Out = A - B;
	}

	void Unity_Branch_float(float Predicate, float True, float False, out float Out)
	{
		Out = lerp(False, True, Predicate);
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		float _Split_7D802A88_R = IN.WorldSpacePosition[0];
		float _Split_7D802A88_G = IN.WorldSpacePosition[1];
		float _Split_7D802A88_B = IN.WorldSpacePosition[2];
		float _Split_7D802A88_A = 0;
		float4 _Combine_C6EF8810_RGBA;
		float3 _Combine_C6EF8810_RGB;
		float2 _Combine_C6EF8810_RG;
		Unity_Combine_float(_Split_7D802A88_R, _Split_7D802A88_G, 0, 0, _Combine_C6EF8810_RGBA, _Combine_C6EF8810_RGB, _Combine_C6EF8810_RG);
		float _Property_74A5754C_Out = Vector1_951C5AAE;
		float _Multiply_D0C65F21_Out;
		Unity_Multiply_float(_Time.y, _Property_74A5754C_Out, _Multiply_D0C65F21_Out);

		float2 _TilingAndOffset_A4885A2_Out;
		Unity_TilingAndOffset_float(_Combine_C6EF8810_RG, float2 (1,1), (_Multiply_D0C65F21_Out.xx), _TilingAndOffset_A4885A2_Out);
		float _Property_60AB6604_Out = Vector1_CEA04AF4;
		float _GradientNoise_99BA3CCA_Out;
		Unity_GradientNoise_float(_TilingAndOffset_A4885A2_Out, _Property_60AB6604_Out, _GradientNoise_99BA3CCA_Out);
		float _Add_98795D5D_Out;
		Unity_Add_float(_GradientNoise_99BA3CCA_Out, -0.5, _Add_98795D5D_Out);
		float _Property_B8B406BC_Out = Vector1_239C1347;
		float _Multiply_57AEF7C0_Out;
		Unity_Multiply_float(_Add_98795D5D_Out, _Property_B8B406BC_Out, _Multiply_57AEF7C0_Out);

		float _Split_A6731F17_R = IN.WorldSpacePosition[0];
		float _Split_A6731F17_G = IN.WorldSpacePosition[1];
		float _Split_A6731F17_B = IN.WorldSpacePosition[2];
		float _Split_A6731F17_A = 0;
		float _Add_4A836434_Out;
		Unity_Add_float(_Multiply_57AEF7C0_Out, _Split_A6731F17_R, _Add_4A836434_Out);
		float4 _Combine_CD92B7DE_RGBA;
		float3 _Combine_CD92B7DE_RGB;
		float2 _Combine_CD92B7DE_RG;
		Unity_Combine_float(_Add_4A836434_Out, _Split_A6731F17_G, _Split_A6731F17_B, 0, _Combine_CD92B7DE_RGBA, _Combine_CD92B7DE_RGB, _Combine_CD92B7DE_RG);
		float4 _UV_C5A2ED5A_Out = IN.uv0;
		float _Split_53CDB402_R = _UV_C5A2ED5A_Out[0];
		float _Split_53CDB402_G = _UV_C5A2ED5A_Out[1];
		float _Split_53CDB402_B = _UV_C5A2ED5A_Out[2];
		float _Split_53CDB402_A = _UV_C5A2ED5A_Out[3];
		float _OneMinus_D1530D6F_Out;
		Unity_OneMinus_float(_Split_53CDB402_R, _OneMinus_D1530D6F_Out);
		float3 _Lerp_A0CD34FA_Out;
		Unity_Lerp_float3(IN.WorldSpacePosition, _Combine_CD92B7DE_RGB, (_OneMinus_D1530D6F_Out.xxx), _Lerp_A0CD34FA_Out);
		float3 _Transform_29C2EC02_Out = TransformWorldToObject(_Lerp_A0CD34FA_Out.xyz);
		description.Position = _Transform_29C2EC02_Out;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float4 _SampleTexture2D_E05DA7F9_RGBA = SAMPLE_TEXTURE2D(Texture2D_CCD5CEA6, samplerTexture2D_CCD5CEA6, IN.uv0.xy);
		float _SampleTexture2D_E05DA7F9_R = _SampleTexture2D_E05DA7F9_RGBA.r;
		float _SampleTexture2D_E05DA7F9_G = _SampleTexture2D_E05DA7F9_RGBA.g;
		float _SampleTexture2D_E05DA7F9_B = _SampleTexture2D_E05DA7F9_RGBA.b;
		float _SampleTexture2D_E05DA7F9_A = _SampleTexture2D_E05DA7F9_RGBA.a;
		float4 _Property_E3377556_Out = Color_4DA8DBE7;
		float4 _Multiply_EEAD26D1_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_RGBA, _Property_E3377556_Out, _Multiply_EEAD26D1_Out);

		float4 _ScreenPosition_D28E9864_Out = float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0);
		float _Dither_643A0E60_Out;
		Unity_Dither_float(2, _ScreenPosition_D28E9864_Out, _Dither_643A0E60_Out);
		float _Multiply_DC3E7522_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_A, _Dither_643A0E60_Out, _Multiply_DC3E7522_Out);

		float _BranchLOD_96078242_Out;
		FadeSwith_float(_BranchLOD_96078242_Out);
		float _Comparison_ACF5C7CE_Out;
		Unity_Comparison_Equal_float(_BranchLOD_96078242_Out, 1, _Comparison_ACF5C7CE_Out);
		float _pLABLOD_5439991_Out;
		StarFunction_float(_pLABLOD_5439991_Out);
		float _Subtract_FEFCB1D5_Out;
		Unity_Subtract_float(1, _pLABLOD_5439991_Out, _Subtract_FEFCB1D5_Out);
		float _Property_C55ABFC9_Out = Vector1_38AC8A3D;
		float _Add_35D2C483_Out;
		Unity_Add_float(_Subtract_FEFCB1D5_Out, _Property_C55ABFC9_Out, _Add_35D2C483_Out);
		float _Branch_F0F84D1C_Out;
		Unity_Branch_float(_Comparison_ACF5C7CE_Out, _Add_35D2C483_Out, _Property_C55ABFC9_Out, _Branch_F0F84D1C_Out);
		surface.Albedo = (_Multiply_EEAD26D1_Out.xyz);
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Alpha = _Multiply_DC3E7522_Out;
		surface.AlphaClipThreshold = _Branch_F0F84D1C_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		float4 ScreenPosition : TEXCOORD8;
		half4 uv0 : TEXCOORD9;
		half4 uv1 : TEXCOORD10;

		UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
	};

	VertexOutput vert(GraphVertexInput v)
	{
		VertexOutput o = (VertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.WorldSpaceNormal = WorldSpaceNormal;
		vdi.WorldSpaceTangent = WorldSpaceTangent;
		vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
		vdi.WorldSpacePosition = WorldSpacePosition;
		vdi.uv0 = uv0;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.ScreenPosition = ScreenPosition;
		o.uv0 = uv0;
		o.uv1 = uv1;

		o.clipPos = TransformObjectToHClip(v.vertex.xyz);
		return o;
	}

	half4 frag(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float4 ScreenPosition = IN.ScreenPosition;
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.ScreenPosition = ScreenPosition;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	clip(Alpha - AlphaClipThreshold);
#endif
	return 0;
	}
		ENDHLSL
	}

		// This pass it not used during regular rendering, only for lightmap baking.
		Pass
	{
		Name "Meta"
		Tags{ "LightMode" = "Meta" }

		Cull Off

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
#pragma prefer_hlslcc gles
#pragma exclude_renderers d3d11_9x
#pragma target 2.0

#pragma vertex vert
#pragma fragment frag

		float4 _MainTex_ST;

	// Defines generated by graph
#define _NORMALMAP 1
#define _AlphaClip 1

#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

#pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

	CBUFFER_START(UnityPerMaterial)
		float Vector1_E27FB99C;
	float Vector1_38AC8A3D;
	float Vector1_85FB8AF6;
	float Vector1_273B1B33;
	float4 Color_4DA8DBE7;
	float Vector1_951C5AAE;
	float Vector1_CEA04AF4;
	float Vector1_239C1347;
	CBUFFER_END

		TEXTURE2D(Texture2D_CCD5CEA6); SAMPLER(samplerTexture2D_CCD5CEA6); float4 Texture2D_CCD5CEA6_TexelSize;
	TEXTURE2D(Texture2D_45F933D); SAMPLER(samplerTexture2D_45F933D); float4 Texture2D_45F933D_TexelSize;

	struct VertexDescriptionInputs
	{
		float3 WorldSpaceNormal;
		float3 WorldSpaceTangent;
		float3 WorldSpaceBiTangent;
		float3 WorldSpacePosition;
		half4 uv0;
	};

	struct SurfaceDescriptionInputs
	{
		float4 ScreenPosition;
		half4 uv0;
	};


	void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
	{
		RGBA = float4(R, G, B, A);
		RGB = float3(R, G, B);
		RG = float2(R, G);
	}

	void Unity_Multiply_float(float A, float B, out float Out)
	{
		Out = A * B;
	}

	void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
	{
		Out = UV * Tiling + Offset;
	}


	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

	void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
	{
		Out = unity_gradientNoise(UV * Scale) + 0.5;
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	void Unity_OneMinus_float(float In, out float Out)
	{
		Out = 1 - In;
	}

	void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
	{
		Out = lerp(A, B, T);
	}

	void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
	{
		Out = A * B;
	}

	void Unity_Dither_float(float In, float4 ScreenPosition, out float Out)
	{
		float2 uv = ScreenPosition.xy * _ScreenParams.xy;
		float DITHER_THRESHOLDS[16] =
		{
			1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
			13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
			4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
			16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
		};
		uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
		Out = In - DITHER_THRESHOLDS[index];
	}

	void FadeSwith_float(out float Out)
	{
#ifdef LOD_FADE_CROSSFADE
		Out = 1;
#else
		Out = 0;
#endif

	}

	void Unity_Comparison_Equal_float(float A, float B, out float Out)
	{
		Out = A == B ? 1 : 0;
	}

	void StarFunction_float(out float Out)
	{
		//#ifdef LOD_FADE_CROSSFADE
		Out = unity_LODFade.x;
		//#else
		//            Out =  1;
		//#endif

	}

	void Unity_Subtract_float(float A, float B, out float Out)
	{
		Out = A - B;
	}

	void Unity_Branch_float(float Predicate, float True, float False, out float Out)
	{
		Out = lerp(False, True, Predicate);
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		float _Split_7D802A88_R = IN.WorldSpacePosition[0];
		float _Split_7D802A88_G = IN.WorldSpacePosition[1];
		float _Split_7D802A88_B = IN.WorldSpacePosition[2];
		float _Split_7D802A88_A = 0;
		float4 _Combine_C6EF8810_RGBA;
		float3 _Combine_C6EF8810_RGB;
		float2 _Combine_C6EF8810_RG;
		Unity_Combine_float(_Split_7D802A88_R, _Split_7D802A88_G, 0, 0, _Combine_C6EF8810_RGBA, _Combine_C6EF8810_RGB, _Combine_C6EF8810_RG);
		float _Property_74A5754C_Out = Vector1_951C5AAE;
		float _Multiply_D0C65F21_Out;
		Unity_Multiply_float(_Time.y, _Property_74A5754C_Out, _Multiply_D0C65F21_Out);

		float2 _TilingAndOffset_A4885A2_Out;
		Unity_TilingAndOffset_float(_Combine_C6EF8810_RG, float2 (1,1), (_Multiply_D0C65F21_Out.xx), _TilingAndOffset_A4885A2_Out);
		float _Property_60AB6604_Out = Vector1_CEA04AF4;
		float _GradientNoise_99BA3CCA_Out;
		Unity_GradientNoise_float(_TilingAndOffset_A4885A2_Out, _Property_60AB6604_Out, _GradientNoise_99BA3CCA_Out);
		float _Add_98795D5D_Out;
		Unity_Add_float(_GradientNoise_99BA3CCA_Out, -0.5, _Add_98795D5D_Out);
		float _Property_B8B406BC_Out = Vector1_239C1347;
		float _Multiply_57AEF7C0_Out;
		Unity_Multiply_float(_Add_98795D5D_Out, _Property_B8B406BC_Out, _Multiply_57AEF7C0_Out);

		float _Split_A6731F17_R = IN.WorldSpacePosition[0];
		float _Split_A6731F17_G = IN.WorldSpacePosition[1];
		float _Split_A6731F17_B = IN.WorldSpacePosition[2];
		float _Split_A6731F17_A = 0;
		float _Add_4A836434_Out;
		Unity_Add_float(_Multiply_57AEF7C0_Out, _Split_A6731F17_R, _Add_4A836434_Out);
		float4 _Combine_CD92B7DE_RGBA;
		float3 _Combine_CD92B7DE_RGB;
		float2 _Combine_CD92B7DE_RG;
		Unity_Combine_float(_Add_4A836434_Out, _Split_A6731F17_G, _Split_A6731F17_B, 0, _Combine_CD92B7DE_RGBA, _Combine_CD92B7DE_RGB, _Combine_CD92B7DE_RG);
		float4 _UV_C5A2ED5A_Out = IN.uv0;
		float _Split_53CDB402_R = _UV_C5A2ED5A_Out[0];
		float _Split_53CDB402_G = _UV_C5A2ED5A_Out[1];
		float _Split_53CDB402_B = _UV_C5A2ED5A_Out[2];
		float _Split_53CDB402_A = _UV_C5A2ED5A_Out[3];
		float _OneMinus_D1530D6F_Out;
		Unity_OneMinus_float(_Split_53CDB402_R, _OneMinus_D1530D6F_Out);
		float3 _Lerp_A0CD34FA_Out;
		Unity_Lerp_float3(IN.WorldSpacePosition, _Combine_CD92B7DE_RGB, (_OneMinus_D1530D6F_Out.xxx), _Lerp_A0CD34FA_Out);
		float3 _Transform_29C2EC02_Out = TransformWorldToObject(_Lerp_A0CD34FA_Out.xyz);
		description.Position = _Transform_29C2EC02_Out;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float4 _SampleTexture2D_E05DA7F9_RGBA = SAMPLE_TEXTURE2D(Texture2D_CCD5CEA6, samplerTexture2D_CCD5CEA6, IN.uv0.xy);
		float _SampleTexture2D_E05DA7F9_R = _SampleTexture2D_E05DA7F9_RGBA.r;
		float _SampleTexture2D_E05DA7F9_G = _SampleTexture2D_E05DA7F9_RGBA.g;
		float _SampleTexture2D_E05DA7F9_B = _SampleTexture2D_E05DA7F9_RGBA.b;
		float _SampleTexture2D_E05DA7F9_A = _SampleTexture2D_E05DA7F9_RGBA.a;
		float4 _Property_E3377556_Out = Color_4DA8DBE7;
		float4 _Multiply_EEAD26D1_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_RGBA, _Property_E3377556_Out, _Multiply_EEAD26D1_Out);

		float4 _ScreenPosition_D28E9864_Out = float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0);
		float _Dither_643A0E60_Out;
		Unity_Dither_float(2, _ScreenPosition_D28E9864_Out, _Dither_643A0E60_Out);
		float _Multiply_DC3E7522_Out;
		Unity_Multiply_float(_SampleTexture2D_E05DA7F9_A, _Dither_643A0E60_Out, _Multiply_DC3E7522_Out);

		float _BranchLOD_96078242_Out;
		FadeSwith_float(_BranchLOD_96078242_Out);
		float _Comparison_ACF5C7CE_Out;
		Unity_Comparison_Equal_float(_BranchLOD_96078242_Out, 1, _Comparison_ACF5C7CE_Out);
		float _pLABLOD_5439991_Out;
		StarFunction_float(_pLABLOD_5439991_Out);
		float _Subtract_FEFCB1D5_Out;
		Unity_Subtract_float(1, _pLABLOD_5439991_Out, _Subtract_FEFCB1D5_Out);
		float _Property_C55ABFC9_Out = Vector1_38AC8A3D;
		float _Add_35D2C483_Out;
		Unity_Add_float(_Subtract_FEFCB1D5_Out, _Property_C55ABFC9_Out, _Add_35D2C483_Out);
		float _Branch_F0F84D1C_Out;
		Unity_Branch_float(_Comparison_ACF5C7CE_Out, _Add_35D2C483_Out, _Property_C55ABFC9_Out, _Branch_F0F84D1C_Out);
		surface.Albedo = (_Multiply_EEAD26D1_Out.xyz);
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Alpha = _Multiply_DC3E7522_Out;
		surface.AlphaClipThreshold = _Branch_F0F84D1C_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		float4 ScreenPosition : TEXCOORD8;
		half4 uv0 : TEXCOORD9;
		half4 uv1 : TEXCOORD10;

		UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
	};

	VertexOutput vert(GraphVertexInput v)
	{
		VertexOutput o = (VertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;


		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.ScreenPosition = ScreenPosition;
		o.uv0 = uv0;
		o.uv1 = uv1;

		o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST);
		return o;
	}

	half4 frag(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float4 ScreenPosition = IN.ScreenPosition;
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.ScreenPosition = ScreenPosition;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	clip(Alpha - AlphaClipThreshold);
#endif

	MetaInput metaInput = (MetaInput)0;
	metaInput.Albedo = Albedo;
	metaInput.Emission = Emission;

	return MetaFragment(metaInput);
	}
		ENDHLSL
	}
	}
		CustomEditor "UnityEditor.ShaderGraph.PBRMasterGUI"
		FallBack "Hidden/InternalErrorShader"
}
